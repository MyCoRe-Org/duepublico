<?xml version="1.0" encoding="UTF-8" ?>

<schema name="MyCoRe-Schema" version="1.5">

  <field name="_version_" type="long" indexed="true" stored="true" />
  <field name="_root_" type="string" indexed="true" stored="false" />

   <!-- kind of mcrobjectid, mcrderivateid, fileid -->
  <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" />

    <!-- Start: MyCoRe specific schema definition -->
  <field name="objectKind" type="string" />
  <field name="objectType" type="string" />
  <field name="objectProject" type="string" />
  <field name="returnId" type="string" />
  <field name="link" type="string" multiValued="true" />
  <field name="derivateLink" type="string" multiValued="true" />
  <field name="category" type="string" multiValued="true" />
  <field name="category.top" type="string" multiValued="true" />
  <field name="worldReadable" type="boolean" />
  <field name="worldReadableComplete" type="boolean" />

  <!-- Alias (/go/* URLs) -->
  <field name="alias" type="string" />

  <field name="created" type="date" />
  <field name="modified" type="date" />
  <field name="createdby" type="string" />
  <field name="modifiedby" type="string" />
  <field name="state" type="string" />

    <!-- parent handling -->
  <field name="parent" type="string" />
  <field name="parentLinkText" type="string" indexed="false" />
  <field name="root" type="string" /> <!-- up all the ancestors -->

    <!-- MCRObject structure -->
  <field name="derivates" type="string" multiValued="true" />
  <field name="derCount" type="int" />

    <!-- ignore all undefined fields -->
  <dynamicField name="*" type="ignored" />
  <dynamicField name="ignored_*" type="ignored" />

    <!-- MCRDerivate related metadata -->
  <field name="derivateURN" type="string" />
  <field name="derivateDisplay" type="boolean" />
  <field name="urn" type="string" multiValued="true" />
  <field name="fileURN" type="string" />
  <field name="fileCategory" type="string" multiValued="true" />
  <field name="maindoc" type="string" />
  <field name="iviewFile" type="string" />

    <!-- MCRFile related fields -->
  <field name="derivateID" type="string" />
  <field name="filePath" type="string" />
  <field name="fileName" type="string" />

    <!-- Tika default fields -->
  <field name="stream_name" type="string" indexed="true" stored="true" />
  <field name="stream_size" type="long" indexed="true" stored="true" />
  <field name="stream_content_type" type="string" />
  <field name="stream_source_info" type="string" />

  <field name="content" type="text_general" stored="false" />

  <field name="payload" type="payloads" />
  <field name="text_wc" type="text_wc" />

    <!-- default search fields -->
  <field name="allMeta" type="text_general" multiValued="true" stored="false" />
  <field name="search_result_link_text" type="text_de" indexed="false" />

    <!-- mycore-mods -->
  <field name="mods.type" type="string" />
  <field name="mods.title" type="text_general" multiValued="true" />
  <field name="mods.title.host" type="text_general" multiValued="true" />
  <field name="mods.title.main" type="collatedGERMAN" />
  <field name="mods.title.subtitle" type="text_de" />
  <field name="mods.nameIdentifier" type="string" multiValued="true" />
  <field name="mods.nameIdentifier.top" type="string" multiValued="true" />
  <field name="mods.name" type="name" multiValued="true" />
  <field name="mods.name.top" type="name" multiValued="true" />
  <field name="mods.author" type="name" multiValued="true" />
  <field name="mods.mainAuthor" type="collatedGERMAN" indexed="true" stored="false" />
  <field name="mods.genre" type="string" multiValued="true" />
  <field name="mods.identifier" type="string" multiValued="true" />
  <field name="mods.identifier.host" type="string" multiValued="true" />
  <field name="mods.abstract" type="text_de" multiValued="true" />
  <field name="mods.abstract.result" type="text_de" indexed="false" />
  <field name="mods.dateIssued" type="string" />
  <field name="mods.dateIssued.host" type="string" />
  <field name="dateOther.type.accepted" type="string" />
  <field name="mods.yearIssued" type="int" />
  <field name="mods.publisher" type="text_de" multiValued="true" />
  <field name="mods.place" type="text_de" multiValued="true" />
  <field name="mods.pindexname" type="string" multiValued="true" />
  <field name="mods.pindexname.published" type="string" multiValued="true" />
  <field name="mods.embargo" type="string" />
  <field name="mods.part" type="string" multiValued="true" />
  <dynamicField name="mods.part.*" type="string" />
  <dynamicField name="mods.part.order*" type="int" />
  <dynamicField name="mods.relatedItem*" type="string" multiValued="true" />

    <!-- ******************************************** -->
    <!-- * SEARCH -->
    <!-- ******************************************** -->
  <field name="title" type="text_general" multiValued="true" stored="false" />
  <field name="title_de" type="text_de" multiValued="true" stored="false" />
  <field name="title_en" type="text_en" multiValued="true" stored="false" />
  <dynamicField name="title_*" type="text_general" multiValued="true" stored="false" />
  <copyField source="title_*" dest="title" />
    <!-- identifier (gnd, pnd, etc.) -->
  <dynamicField name="id.*" type="string" />

    <!-- all names (personal and corporate) with role in fieldname -->
  <dynamicField name="mods.nameByRole.*" type="name" multiValued="true" />

  <field name="mods.name.conference" type="string" multiValued="true" />

  <dynamicField name="identifier.type.*" type="string" multiValued="true" />
  <field name="topic" type="string" multiValued="true" />

    <!-- End: MyCoRe specific schema definition -->

    <!-- MIR specific schema -->
  <field name="isbn" type="string" multiValued="true" />

  <uniqueKey>id</uniqueKey>

  <fieldType name="string" class="solr.StrField" sortMissingLast="true" />
  <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" />
  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0" />
  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0" />
  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0" />
  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0" />
  <fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0" />
  
  <!-- Field type for names such as author, editor, place -->
  <fieldType name="name" class="solr.TextField" positionIncrementGap="100">
    <analyzer type="index">
      <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="[\-\.]" replacement=" " />
      <!-- Turnbull, Douglas G ==> Turnbull, Douglas D G to force all initials found -->
      <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="\s+(\S)(\S+)" replacement=" $1$2 $1" /> <!-- Douglas Harold ==> Douglas D Harold H -->
      <tokenizer class="solr.StandardTokenizerFactory" />
      <filter class="solr.GermanNormalizationFilterFactory" />
      <filter class="solr.ICUNormalizer2FilterFactory" name="nfkc_cf" mode="compose" />
      <filter class="solr.ICUFoldingFilterFactory" />
    </analyzer>
    <analyzer type="query">
      <tokenizer class="solr.StandardTokenizerFactory" />
      <filter class="solr.GermanNormalizationFilterFactory" />
      <filter class="solr.ICUNormalizer2FilterFactory" name="nfkc_cf" mode="compose" />
      <filter class="solr.ICUFoldingFilterFactory" />
    </analyzer>
  </fieldType>
  
  <!-- A text field that only splits on whitespace for exact matching of words -->
  <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
    <analyzer>
      <tokenizer class="solr.WhitespaceTokenizerFactory" />
    </analyzer>
  </fieldType>

    <!-- A general text field that has reasonable, generic
         cross-language defaults: it tokenizes with StandardTokenizer,
   removes stop words from case-insensitive "stopwords.txt"
   (empty by default), and down cases.  At query time only, it
   also applies synonyms. -->
  <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
    <analyzer type="index">
      <tokenizer class="solr.StandardTokenizerFactory" />
      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
          <!-- in this example, we will only use synonyms at query time
          <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
          -->
      <filter class="solr.LowerCaseFilterFactory" />
    </analyzer>
    <analyzer type="query">
      <tokenizer class="solr.StandardTokenizerFactory" />
      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true" />
      <filter class="solr.LowerCaseFilterFactory" />
    </analyzer>
  </fieldType>

    <!-- A text field with defaults appropriate for English: it
         tokenizes with StandardTokenizer, removes English stop words
         (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
         finally applies Porter's stemming.  The query time analyzer
         also applies synonyms from synonyms.txt. -->
  <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
    <analyzer type="index">
      <tokenizer class="solr.StandardTokenizerFactory" />
        <!-- in this example, we will only use synonyms at query time
        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
        -->
          <!-- Case insensitive stop word removal.
        -->
      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt" />
      <filter class="solr.LowerCaseFilterFactory" />
      <filter class="solr.EnglishPossessiveFilterFactory" />
      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt" />
    <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
          <filter class="solr.EnglishMinimalStemFilterFactory"/>
    -->
      <filter class="solr.PorterStemFilterFactory" />
    </analyzer>
    <analyzer type="query">
      <tokenizer class="solr.StandardTokenizerFactory" />
      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true" />
      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt" />
      <filter class="solr.LowerCaseFilterFactory" />
      <filter class="solr.EnglishPossessiveFilterFactory" />
      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt" />
    <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
          <filter class="solr.EnglishMinimalStemFilterFactory"/>
    -->
      <filter class="solr.PorterStemFilterFactory" />
    </analyzer>
  </fieldType>

    <!-- text with word coordinates -->
  <fieldtype name="text_wc" stored="false" class="solr.TextField" multiValued="true">
    <analyzer type="index">
      <tokenizer class="solr.WhitespaceTokenizerFactory" />
      <filter class="solr.DelimitedPayloadTokenFilterFactory" delimiter="|" encoder="identity" />
      <filter class="solr.LowerCaseFilterFactory" />
      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" enablePositionIncrements="true" />
      <filter class="solr.ASCIIFoldingFilterFactory" />
      <filter class="solr.ICUNormalizer2FilterFactory" />
      <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="[^\p{L}\p{Nd}]" replacement="" />
    </analyzer>
    <analyzer type="query">
      <tokenizer class="solr.WhitespaceTokenizerFactory" />
      <filter class="solr.LowerCaseFilterFactory" />
      <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" enablePositionIncrements="true" />
      <filter class="solr.ASCIIFoldingFilterFactory" />
      <filter class="solr.ICUNormalizer2FilterFactory" />
      <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="[^\p{L}\p{Nd}]" replacement="" />
    </analyzer>
  </fieldtype>

    <!-- define a field type for German collation, see http://wiki.apache.org/solr/UnicodeCollation -->
  <fieldType name="collatedGERMAN" class="solr.TextField">
    <analyzer>
      <tokenizer class="solr.KeywordTokenizerFactory" />
      <filter class="solr.CollationKeyFilterFactory" language="de" strength="primary" />
    </analyzer>
  </fieldType>

  <fieldtype name="payloads" stored="false" indexed="true" class="solr.TextField">
    <analyzer>
      <tokenizer class="solr.WhitespaceTokenizerFactory" />
        <!--
        The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
        a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
        Attributes of the DelimitedPayloadTokenFilterFactory :
         "delimiter" - a one character delimiter. Default is | (pipe)
   "encoder" - how to encode the following value into a playload
      float -> org.apache.lucene.analysis.payloads.FloatEncoder,
      integer -> o.a.l.a.p.IntegerEncoder
      identity -> o.a.l.a.p.IdentityEncoder
            Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
         -->
      <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float" />
    </analyzer>
  </fieldtype>

    <!-- since fields of this type are by default not stored or indexed,
         any data added to them will be ignored outright.  -->
  <fieldtype name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField" />

    <!-- German -->
  <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
    <analyzer type="index">
      <charFilter class="solr.MappingCharFilterFactory" mapping="mapping.txt" />
      <tokenizer class="solr.StandardTokenizerFactory" />
      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1"
        catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="0" />
      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball"
        enablePositionIncrements="true" />
      <filter class="solr.LowerCaseFilterFactory" />
      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt" />
      <filter class="solr.SnowballPorterFilterFactory" language="German2" />
      <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
      <filter class="solr.LengthFilterFactory" min="3" max="100" />
      <filter class="solr.GermanNormalizationFilterFactory" />
      <filter class="solr.GermanLightStemFilterFactory" />
        <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
    </analyzer>
    <analyzer type="query">
      <charFilter class="solr.MappingCharFilterFactory" mapping="mapping.txt" />
      <tokenizer class="solr.StandardTokenizerFactory" />
      <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true" />
      <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1"
        catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" />
      <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball"
        enablePositionIncrements="true" />
      <filter class="solr.LowerCaseFilterFactory" />
      <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt" />
      <filter class="solr.SnowballPorterFilterFactory" language="German2" />
      <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
      <filter class="solr.LengthFilterFactory" min="3" max="100" />
      <filter class="solr.GermanNormalizationFilterFactory" />
      <filter class="solr.GermanLightStemFilterFactory" />
        <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
    </analyzer>
  </fieldType>

</schema>
